substitutions:
  name: atom-echo
  friendly_name: Atom Echo

esphome:
  name: ${name}
  friendly_name: ${friendly_name}

esp32:
  board: m5stack-atom
  cpu_frequency: 240MHz
  framework:
    type: esp-idf

logger:
  level: INFO

safe_mode:
  boot_is_good_after: 1min
  num_attempts: 10
  reboot_timeout: 5min

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  power_save_mode: none
  ap: {}

api:
  reboot_timeout: 0s
  encryption:
    key: FZD1Uawj+EJum/aIzFxa/VkHF11ehVT6uP2Gv2FB4lw=

ota:
  - platform: esphome
    password: "bd0c8d0f698358a6436ba3134414e856"

globals:
  # 0=idle, 1=listening, 2=processing, 3=speaking/announcing
  - id: va_phase
    type: uint8_t
    restore_value: no
    initial_value: '0'

button:
  - platform: restart
    id: restart_btn
    name: "${friendly_name} Restart"
    entity_category: config

  - platform: safe_mode
    id: safe_mode_btn
    name: "${friendly_name} Restart (Safe Mode)"
    entity_category: config

  - platform: factory_reset
    id: factory_reset_btn
    name: "${friendly_name} Factory Reset"
    entity_category: config

i2s_audio:
  - id: i2s_audio_bus
    i2s_lrclk_pin: GPIO33
    i2s_bclk_pin: GPIO19

microphone:
  - platform: i2s_audio
    id: echo_microphone
    i2s_din_pin: GPIO23
    adc_type: external
    pdm: true
    sample_rate: 16000
    correct_dc_offset: true

speaker:
  - platform: i2s_audio
    id: echo_speaker
    i2s_dout_pin: GPIO22
    dac_type: external
    bits_per_sample: 16bit
    sample_rate: 16000
    channel: stereo
    buffer_duration: 60ms

media_player:
  - platform: speaker
    id: echo_media_player
    name: ""
    internal: true
    announcement_pipeline:
      speaker: echo_speaker
      format: WAV
    codec_support_enabled: false
    buffer_size: 6000
    volume_min: 0.4
    files:
      - id: timer_finished_wave_file
        file: https://github.com/esphome/wake-word-voice-assistants/raw/main/sounds/timer_finished.wav

    on_announcement:
      - if:
          condition:
            - microphone.is_capturing:
          then:
            - script.execute: stop_wake_word
      - if:
          condition:
            - switch.is_off: timer_ringing
          then:
            - lambda: id(va_phase) = 3;
            - script.execute: reset_led

    on_idle:
      - if:
          condition:
            - switch.is_off: timer_ringing
          then:
            - script.execute: start_wake_word

voice_assistant:
  id: va
  microphone:
    microphone: echo_microphone
    channels: 0
    gain_factor: 4
  media_player: echo_media_player
  noise_suppression_level: 2
  auto_gain: 31dBFS

  on_listening:
    - lambda: id(va_phase) = 1;
    - script.execute: reset_led

  on_stt_vad_end:
    - lambda: id(va_phase) = 2;
    - script.execute: reset_led

  on_tts_start:
    - lambda: id(va_phase) = 3;
    - script.execute: reset_led

  on_end:
    - lambda: id(va_phase) = 0;
    - wait_until:
        condition:
          - media_player.is_announcing:
              id: echo_media_player
        timeout: 0.5s
    - if:
        condition:
          - and:
              - switch.is_off: timer_ringing
              - lambda: |-
                  return id(wake_word_engine_location).current_option() == "On device";
        then:
          - wait_until:
              condition:
                - and:
                    - not: voice_assistant.is_running
                    - not: speaker.is_playing
              timeout: 2s
          - if:
              condition:
                - switch.is_off: mute_mic
              then:
                - lambda: id(va).set_use_wake_word(false);
                - micro_wake_word.start
    - script.execute: reset_led

  on_error:
    - lambda: id(va_phase) = 0;
    - if:
        condition:
          - switch.is_off: timer_ringing
        then:
          - light.turn_on:
              id: led
              red: 100%
              green: 0%
              blue: 0%
              brightness: 100%
              effect: none
          - delay: 2s
    - script.execute: reset_led

  on_client_connected:
    - delay: 2s
    - script.execute: start_wake_word

  on_client_disconnected:
    - script.execute: stop_wake_word
    - script.execute: reset_led

  on_timer_finished:
    - script.execute: stop_wake_word
    - wait_until:
        condition:
          - not: microphone.is_capturing
        timeout: 2s
    - switch.turn_on: timer_ringing
    - light.turn_on:
        id: led
        red: 0%
        green: 100%
        blue: 0%
        brightness: 100%
        effect: "Fast Pulse"
    - wait_until:
        condition:
          - switch.is_off: timer_ringing
        timeout: 16min
    - light.turn_off: led
    - switch.turn_off: timer_ringing

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO39
      inverted: true
    name: Button
    disabled_by_default: true
    entity_category: diagnostic
    id: echo_button
    on_multi_click:
      - timing:
          - ON for at least 8s
        then:
          - button.press: factory_reset_btn

      - timing:
          - ON for at least 3s
          - OFF for at least 50ms
        then:
          - switch.toggle: mute_mic

      - timing:
          - ON for at least 50ms
          - OFF for at least 50ms
        then:
          - if:
              condition:
                switch.is_on: timer_ringing
              then:
                - switch.turn_off: timer_ringing
              else:
                - script.execute: start_wake_word

output:
  # No-op outputs used only to expose HA "color picker" lights for status LED settings.
  - platform: template
    id: idle_r_out
    type: float
    write_action:
      - lambda: |-
          (void) state;
  - platform: template
    id: idle_g_out
    type: float
    write_action:
      - lambda: |-
          (void) state;
  - platform: template
    id: idle_b_out
    type: float
    write_action:
      - lambda: |-
          (void) state;

  - platform: template
    id: listening_r_out
    type: float
    write_action:
      - lambda: |-
          (void) state;
  - platform: template
    id: listening_g_out
    type: float
    write_action:
      - lambda: |-
          (void) state;
  - platform: template
    id: listening_b_out
    type: float
    write_action:
      - lambda: |-
          (void) state;

  - platform: template
    id: processing_r_out
    type: float
    write_action:
      - lambda: |-
          (void) state;
  - platform: template
    id: processing_g_out
    type: float
    write_action:
      - lambda: |-
          (void) state;
  - platform: template
    id: processing_b_out
    type: float
    write_action:
      - lambda: |-
          (void) state;

  - platform: template
    id: speaking_r_out
    type: float
    write_action:
      - lambda: |-
          (void) state;
  - platform: template
    id: speaking_g_out
    type: float
    write_action:
      - lambda: |-
          (void) state;
  - platform: template
    id: speaking_b_out
    type: float
    write_action:
      - lambda: |-
          (void) state;

light:
  # Status LED color/brightness "settings" (these are NOT the physical LED).
  - platform: rgb
    id: status_idle
    name: "${friendly_name} Status LED - Idle"
    entity_category: config
    restore_mode: RESTORE_DEFAULT_ON
    default_transition_length: 0s
    red: idle_r_out
    green: idle_g_out
    blue: idle_b_out
    initial_state:
      state: true
      brightness: 60%
      red: 100%
      green: 89%
      blue: 71%
    on_state:
      - script.execute: reset_led

  - platform: rgb
    id: status_listening
    name: "${friendly_name} Status LED - Listening"
    entity_category: config
    restore_mode: RESTORE_DEFAULT_ON
    default_transition_length: 0s
    red: listening_r_out
    green: listening_g_out
    blue: listening_b_out
    initial_state:
      state: true
      brightness: 100%
      red: 0%
      green: 0%
      blue: 100%
    on_state:
      - script.execute: reset_led

  - platform: rgb
    id: status_processing
    name: "${friendly_name} Status LED - Processing"
    entity_category: config
    restore_mode: RESTORE_DEFAULT_ON
    default_transition_length: 0s
    red: processing_r_out
    green: processing_g_out
    blue: processing_b_out
    initial_state:
      state: true
      brightness: 100%
      red: 0%
      green: 0%
      blue: 100%
    on_state:
      - script.execute: reset_led

  - platform: rgb
    id: status_speaking
    name: "${friendly_name} Status LED - Speaking"
    entity_category: config
    restore_mode: RESTORE_DEFAULT_ON
    default_transition_length: 0s
    red: speaking_r_out
    green: speaking_g_out
    blue: speaking_b_out
    initial_state:
      state: true
      brightness: 100%
      red: 0%
      green: 0%
      blue: 100%
    on_state:
      - script.execute: reset_led

  # Physical LED (internal).
  - platform: esp32_rmt_led_strip
    id: led
    name: ""
    internal: true
    pin: GPIO27
    default_transition_length: 0s
    chipset: SK6812
    num_leds: 1
    rgb_order: grb
    effects:
      - pulse:
          name: "Slow Pulse"
          transition_length: 250ms
          update_interval: 250ms
          min_brightness: 50%
          max_brightness: 100%
      - pulse:
          name: "Fast Pulse"
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 50%
          max_brightness: 100%

script:
  - id: reset_led
    mode: restart
    then:
      - lambda: |-
          // Timer ring owns the LED.
          if (id(timer_ringing).state) {
            return;
          }

          constexpr uint32_t EFFECT_NONE = 0;
          constexpr uint32_t EFFECT_SLOW_PULSE = 1;  // "Slow Pulse" (1st configured effect)
          constexpr uint32_t EFFECT_FAST_PULSE = 2;  // "Fast Pulse" (2nd configured effect)

          // Mic muted always wins.
          if (id(mute_mic).state) {
            auto call = id(led).turn_on();
            call.set_transition_length(0);
            call.set_rgb(1.0f, 0.0f, 0.0f);
            call.set_brightness(0.40f);
            call.set_effect(EFFECT_NONE);
            call.perform();
            return;
          }

          auto load_rgb_settings = [](auto &src, float &r, float &g, float &b) {
            auto &cv = src.remote_values;

            // Treat these "setting lights" as always-on: ignore cv.get_state().
            const float br = cv.get_brightness();
            const float cbr = cv.get_color_brightness();

            r = cv.get_red()   * br * cbr;
            g = cv.get_green() * br * cbr;
            b = cv.get_blue()  * br * cbr;

            // Hard clamp (defensive).
            if (r < 0.0f) r = 0.0f;
            if (r > 1.0f) r = 1.0f;
            if (g < 0.0f) g = 0.0f;
            if (g > 1.0f) g = 1.0f;
            if (b < 0.0f) b = 0.0f;
            if (b > 1.0f) b = 1.0f;
          };

          float r = 0.0f, g = 0.0f, b = 0.0f;
          uint32_t effect = EFFECT_NONE;

          const uint8_t phase = id(va_phase);
          if (phase == 1) {
            load_rgb_settings(id(status_listening), r, g, b);
            effect = EFFECT_SLOW_PULSE;
          } else if (phase == 2) {
            load_rgb_settings(id(status_processing), r, g, b);
            effect = EFFECT_FAST_PULSE;
          } else if (phase == 3) {
            load_rgb_settings(id(status_speaking), r, g, b);
            effect = EFFECT_NONE;
          } else {
            // Idle.
            const bool on_device = id(wake_word_engine_location).current_option() == "On device";
            if (id(use_listen_light).state && on_device) {
              load_rgb_settings(id(status_idle), r, g, b);
              effect = EFFECT_NONE;
            } else {
              auto off = id(led).turn_off();
              off.set_transition_length(0);
              off.perform();
              return;
            }
          }

          auto call = id(led).turn_on();
          call.set_transition_length(0);
          call.set_rgb(r, g, b);
          call.set_brightness(1.0f);
          call.set_effect(effect);
          call.perform();

  - id: start_wake_word
    mode: restart
    then:
      - lambda: id(va_phase) = 0;
      - if:
          condition:
            - switch.is_on: mute_mic
          then:
            - script.execute: reset_led
          else:
            - if:
                condition:
                  - and:
                      - not: voice_assistant.is_running
                      - lambda: |-
                          return id(wake_word_engine_location).current_option() == "On device";
                then:
                  - lambda: id(va).set_use_wake_word(false);
                  - micro_wake_word.start
            - if:
                condition:
                  - and:
                      - not: voice_assistant.is_running
                      - lambda: |-
                          return id(wake_word_engine_location).current_option() == "In Home Assistant";
                then:
                  - lambda: id(va).set_use_wake_word(true);
                  - voice_assistant.start_continuous
            - script.execute: reset_led

  - id: stop_wake_word
    mode: restart
    then:
      - lambda: id(va_phase) = 0;
      - if:
          condition:
            - lambda: |-
                return id(wake_word_engine_location).current_option() == "In Home Assistant";
          then:
            - lambda: id(va).set_use_wake_word(false);
            - voice_assistant.stop
      - if:
          condition:
            - lambda: |-
                return id(wake_word_engine_location).current_option() == "On device";
          then:
            - micro_wake_word.stop

switch:
  - platform: template
    name: Use listen light
    id: use_listen_light
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    entity_category: config
    on_turn_on:
      - script.execute: reset_led
    on_turn_off:
      - script.execute: reset_led

  - platform: template
    name: Mute mic
    id: mute_mic
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_on:
      - script.execute: stop_wake_word
      - script.execute: reset_led
    on_turn_off:
      - script.execute: start_wake_word
      - script.execute: reset_led

  - platform: template
    id: timer_ringing
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      - lambda: |-
          id(echo_media_player)
            ->make_call()
            .set_command(media_player::MEDIA_PLAYER_COMMAND_REPEAT_OFF)
            .set_announcement(true)
            .perform();
          id(echo_media_player)->set_playlist_delay_ms(
            speaker::AudioPipelineType::ANNOUNCEMENT, 0);
      - media_player.stop:
          id: echo_media_player
          announcement: true
    on_turn_on:
      - lambda: |-
          id(echo_media_player)
            ->make_call()
            .set_command(media_player::MEDIA_PLAYER_COMMAND_REPEAT_ONE)
            .set_announcement(true)
            .perform();
          id(echo_media_player)->set_playlist_delay_ms(
            speaker::AudioPipelineType::ANNOUNCEMENT, 1000);
      - media_player.speaker.play_on_device_media_file:
          id: echo_media_player
          media_file: timer_finished_wave_file
          announcement: true
      - delay: 15min
      - switch.turn_off: timer_ringing

select:
  - platform: template
    entity_category: config
    name: Wake word engine location
    id: wake_word_engine_location
    optimistic: true
    restore_value: true
    options:
      - In Home Assistant
      - On device
    initial_option: On device
    on_value:
      - lambda: id(va_phase) = 0;
      - if:
          condition:
            - lambda: return x == "In Home Assistant";
          then:
            - micro_wake_word.stop
            - delay: 500ms
            - lambda: id(va).set_use_wake_word(true);
            - voice_assistant.start_continuous
            - script.execute: reset_led
      - if:
          condition:
            - lambda: return x == "On device";
          then:
            - lambda: id(va).set_use_wake_word(false);
            - voice_assistant.stop
            - delay: 500ms
            - if:
                condition:
                  - switch.is_off: mute_mic
                then:
                  - micro_wake_word.start
            - script.execute: reset_led

micro_wake_word:
  on_wake_word_detected:
    - if:
        condition:
          - switch.is_off: mute_mic
        then:
          - voice_assistant.start:
              wake_word: !lambda return wake_word;
  vad: {}
  models:
    - model: okay_nabu
    - model: hey_mycroft
    - model: hey_jarvis

light:
  - platform: esp32_rmt_led_strip
    id: status_listening
    name: "${friendly_name} Status LED"
    pin: GPIO27
    num_leds: 1
    chipset: WS2812
    rgb_order: GRB
    on_turn_on:
      - lambda: |-
          auto *src = id(status_listening);
          auto &cv = src->remote_values;
          float r = cv.get_red();
          float g = cv.get_green();
          float b = cv.get_blue();
          // Use the captured RGB values in your existing status handler.
